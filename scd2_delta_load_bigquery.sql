
-- SCD TYPE 2 DELTA LOAD DEMO

-- Step 0: Set Infinity and Cutoff
DECLARE _infinity_ts DATETIME DEFAULT '9999-12-31 23:59:59';
DECLARE _cutoff_ts DATETIME DEFAULT '2025-01-05 00:00:00';

-- Step 1: History Table
CREATE TEMP TABLE history AS
SELECT * FROM UNNEST([
  STRUCT(1 AS AGREEMENT_IDENTIFIER, 'A1' AS SOURCE_SYSTEM_AGREEMENT_NUMBER,
         DATETIME '2025-01-01 00:00:00' AS EFFECTIVE_FROM_DATE,
         _infinity_ts AS EFFECTIVE_TO_DATE,
         CAST(FARM_FINGERPRINT('A1|100') AS INT64) AS ROW_HASH),

  STRUCT(2, 'B1', DATETIME '2025-01-01 00:00:00',
         DATETIME_SUB(_cutoff_ts, INTERVAL 1 DAY),
         CAST(FARM_FINGERPRINT('B1|200') AS INT64)),

  STRUCT(2, 'B1', DATETIME_SUB(_cutoff_ts, INTERVAL 0 DAY),
         _infinity_ts,
         CAST(FARM_FINGERPRINT('B1|201') AS INT64))
]);

-- Step 2: Feed Table (Delta)
CREATE TEMP TABLE feed AS
SELECT * FROM UNNEST([
  STRUCT('A1' AS SOURCE_SYSTEM_AGREEMENT_NUMBER,
         DATETIME '2025-01-05 00:00:00' AS EFFECTIVE_FROM_DATE,
         _infinity_ts AS EFFECTIVE_TO_DATE,
         CAST(FARM_FINGERPRINT('A1|110') AS INT64) AS ROW_HASH),

  STRUCT('B1', _cutoff_ts, _infinity_ts,
         CAST(FARM_FINGERPRINT('B1|201') AS INT64)),

  STRUCT('C1', _cutoff_ts, _infinity_ts,
         CAST(FARM_FINGERPRINT('C1|300') AS INT64))
]);

-- Step 3: Current Live Rows
CREATE TEMP TABLE current_live AS
SELECT *
FROM (
  SELECT *,
         ROW_NUMBER() OVER (PARTITION BY SOURCE_SYSTEM_AGREEMENT_NUMBER ORDER BY EFFECTIVE_FROM_DATE DESC) AS rn
  FROM history
  WHERE EFFECTIVE_TO_DATE = _infinity_ts
)
WHERE rn = 1;

-- Step 4: ID Mapping
CREATE TEMP TABLE id_map AS
WITH distinct_keys AS (
  SELECT DISTINCT SOURCE_SYSTEM_AGREEMENT_NUMBER FROM feed
),
max_existing AS (
  SELECT COALESCE(MAX(AGREEMENT_IDENTIFIER), 0) AS max_id FROM history
),
new_keys AS (
  SELECT dk.SOURCE_SYSTEM_AGREEMENT_NUMBER
  FROM distinct_keys dk
  LEFT JOIN current_live cl
    ON dk.SOURCE_SYSTEM_AGREEMENT_NUMBER = cl.SOURCE_SYSTEM_AGREEMENT_NUMBER
  WHERE cl.SOURCE_SYSTEM_AGREEMENT_NUMBER IS NULL
),
new_ids AS (
  SELECT
    SOURCE_SYSTEM_AGREEMENT_NUMBER,
    ROW_NUMBER() OVER (ORDER BY SOURCE_SYSTEM_AGREEMENT_NUMBER)
      + (SELECT max_id FROM max_existing) AS AGREEMENT_IDENTIFIER
  FROM new_keys
)
SELECT
  cl.SOURCE_SYSTEM_AGREEMENT_NUMBER,
  cl.AGREEMENT_IDENTIFIER
FROM current_live cl
UNION ALL
SELECT * FROM new_ids;

-- Step 5: Compare Feed and History
CREATE TEMP TABLE staging AS
SELECT
  f.SOURCE_SYSTEM_AGREEMENT_NUMBER,
  m.AGREEMENT_IDENTIFIER,
  f.EFFECTIVE_FROM_DATE,
  f.EFFECTIVE_TO_DATE,
  f.ROW_HASH,
  cl.ROW_HASH AS existing_hash,
  CASE
    WHEN cl.ROW_HASH IS NULL THEN 'INSERT'
    WHEN cl.ROW_HASH <> f.ROW_HASH THEN 'UPDATE'
    ELSE 'UNCHANGED'
  END AS ACTION
FROM feed f
JOIN id_map m USING (SOURCE_SYSTEM_AGREEMENT_NUMBER)
LEFT JOIN current_live cl
  ON f.SOURCE_SYSTEM_AGREEMENT_NUMBER = cl.SOURCE_SYSTEM_AGREEMENT_NUMBER;

-- Step 6A: Close Old Version
UPDATE history h
SET EFFECTIVE_TO_DATE = DATETIME_SUB(_cutoff_ts, INTERVAL 1 SECOND)
WHERE EXISTS (
  SELECT 1 FROM staging s
  WHERE s.ACTION = 'UPDATE'
    AND h.AGREEMENT_IDENTIFIER = s.AGREEMENT_IDENTIFIER
    AND h.EFFECTIVE_TO_DATE = _infinity_ts
);

-- Step 6B: Insert New Versions
INSERT INTO history (
  AGREEMENT_IDENTIFIER,
  SOURCE_SYSTEM_AGREEMENT_NUMBER,
  EFFECTIVE_FROM_DATE,
  EFFECTIVE_TO_DATE,
  ROW_HASH
)
SELECT
  AGREEMENT_IDENTIFIER,
  SOURCE_SYSTEM_AGREEMENT_NUMBER,
  EFFECTIVE_FROM_DATE,
  EFFECTIVE_TO_DATE,
  ROW_HASH
FROM staging
WHERE ACTION IN ('INSERT', 'UPDATE');

-- Step 7: Log Summary
CREATE TEMP TABLE agreement_processing_log AS
SELECT
  'DELTA' AS processing_type,
  _cutoff_ts AS last_processed_timestamp,
  COUNT(*) AS total_records,
  SUM(CASE WHEN ACTION = 'INSERT' THEN 1 ELSE 0 END) AS inserted,
  SUM(CASE WHEN ACTION = 'UPDATE' THEN 1 ELSE 0 END) AS updated,
  SUM(CASE WHEN ACTION = 'UNCHANGED' THEN 1 ELSE 0 END) AS unchanged
FROM staging;

-- Final View
SELECT * FROM history ORDER BY SOURCE_SYSTEM_AGREEMENT_NUMBER, EFFECTIVE_FROM_DATE;
